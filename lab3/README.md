# Сопроводительная документация

### Оглавление
1. [Общее описание](#общее-описание)
2. [Архитектура приложения](#архитектура-приложения)
3. [Реализованные методы](#реализованные-методы)
4. [Технические детали](#технические-детали)
5. [Руководство пользователя](#руководство-пользователя)
6. [Примеры использования](#примеры-использования)
7. [Зависимости](#зависимости)

---

## Общее описание

Приложение представляет собой программу с графическим интерфейсом для обработки изображений, реализующую следующие методы:
- **Локальная пороговая обработка** (методы Niblack и Sauvola)
- **Адаптивная пороговая обработка** (Mean и Gaussian)
- **Поэлементные операции** (сложение, вычитание, умножение, деление)
- **Линейное контрастирование**

### Основные возможности
- Загрузка изображений различных форматов (JPG, PNG, BMP, TIFF)
- Просмотр оригинального и обработанного изображения одновременно
- Настройка параметров для каждого метода обработки
- Сохранение результатов обработки
- Сброс к исходному изображению

---

## Архитектура приложения

### Структура класса `ImageProcessorApp`

```
ImageProcessorApp
├── __init__(self, root)              # Инициализация приложения
├── setup_ui(self)                    # Настройка интерфейса
├── load_image(self)                  # Загрузка изображения
├── display_images(self)              # Отображение изображений
├── resize_for_display(self, image)   # Масштабирование для отображения
├── get_grayscale(self)               # Конвертация в оттенки серого
│
├── Локальная пороговая обработка
│   ├── apply_niblack(self)
│   ├── niblack_threshold(self, image, window_size, k)
│   ├── apply_sauvola(self)
│   └── sauvola_threshold(self, image, window_size, k, R)
│
├── Адаптивная пороговая обработка
│   └── apply_adaptive_threshold(self, method)
│
├── Поэлементные операции
│   └── apply_element_operation(self, operation)
│
├── Линейное контрастирование
│   └── apply_linear_contrast(self)
│
└── Вспомогательные функции
    ├── reset_image(self)
    └── save_image(self)
```

### Переменные класса

| Переменная | Тип | Описание |
|------------|-----|----------|
| `root` | tk.Tk | Главное окно приложения |
| `original_image` | np.ndarray | Исходное изображение (BGR формат) |
| `processed_image` | np.ndarray | Обработанное изображение |
| `display_size` | tuple | Размер для отображения (600x400) |

---

## Реализованные методы

### 1. Локальная пороговая обработка

#### 1.1. Метод Niblack

**Описание:** Локальный адаптивный метод бинаризации, использующий статистические характеристики локальной области.

**Формула:**
```
T(x,y) = m(x,y) + k × σ(x,y)
```
где:
- `T(x,y)` — пороговое значение для пикселя (x,y)
- `m(x,y)` — локальное среднее значение
- `σ(x,y)` — локальное стандартное отклонение
- `k` — коэффициент чувствительности (обычно от -1 до 1)

**Параметры:**
- **Размер окна** (3-51, нечетное): определяет размер локальной области
- **k** (-1.0 до 1.0): контролирует влияние стандартного отклонения
  - Отрицательные значения: делает изображение темнее
  - Положительные значения: делает изображение светлее

**Применение:**
Хорошо работает для изображений с неравномерным освещением, текстовых документов.

**Реализация:**
```python
def niblack_threshold(self, image: np.ndarray, window_size: int, k: float) -> np.ndarray:
    mean = cv2.blur(image.astype(np.float32), (window_size, window_size))
    mean_sq = cv2.blur((image.astype(np.float32) ** 2), (window_size, window_size))
    std = np.sqrt(mean_sq - mean ** 2)
    threshold = mean + k * std
    return threshold
```

#### 1.2. Метод Sauvola

**Описание:** Улучшенная версия метода Niblack, специально разработанная для бинаризации документов.

**Формула:**
```
T(x,y) = m(x,y) × [1 + k × (σ(x,y)/R - 1)]
```
где:
- `R` — динамический диапазон стандартного отклонения (обычно 128 для 8-битных изображений)
- `k` — коэффициент (обычно 0.2-0.5)

**Параметры:**
- **Размер окна** (3-51, нечетное): размер локальной области
- **k** (0.0 до 1.0): коэффициент чувствительности

**Преимущества перед Niblack:**
- Лучше работает на фоновых областях
- Меньше шума в результате
- Более подходит для документов

**Применение:**
Оптимален для сканированных документов, текста с различным контрастом.

---

### 2. Адаптивная пороговая обработка

#### 2.1. Adaptive Mean Threshold

**Описание:** Порог вычисляется как среднее арифметическое значений пикселей в локальной области минус константа C.

**Формула:**
```
T(x,y) = mean(x,y) - C
```

**Параметры:**
- **Размер окна** (3-51, нечетное): размер области для вычисления среднего
- **C** (-10 до 10): константа, вычитаемая из среднего

#### 2.2. Adaptive Gaussian Threshold

**Описание:** Порог вычисляется как взвешенная сумма (гауссово взвешивание) значений пикселей в локальной области минус константа C.

**Формула:**
```
T(x,y) = weighted_mean(x,y) - C
```

**Параметры:**
- **Размер окна** (3-51, нечетное): размер области
- **C** (-10 до 10): константа коррекции

**Сравнение методов:**

| Метод | Преимущества | Недостатки |
|-------|--------------|------------|
| Mean | Быстрее, проще | Чувствителен к резким перепадам |
| Gaussian | Более гладкий результат | Медленнее |

**Применение:**
Используется OpenCV функция `cv2.adaptiveThreshold()` с соответствующими флагами.

---

### 3. Поэлементные операции

Операции выполняются над каждым пикселем изображения независимо.

#### 3.1. Сложение (Add)

**Формула:**
```
result(x,y) = image(x,y) + value
```

**Эффект:** Увеличивает яркость изображения

**Пример использования:**
- Осветление темных изображений
- Увеличение общей яркости

#### 3.2. Вычитание (Subtract)

**Формула:**
```
result(x,y) = image(x,y) - value
```

**Эффект:** Уменьшает яркость изображения

**Пример использования:**
- Затемнение пересвеченных изображений
- Создание эффекта тени

#### 3.3. Умножение (Multiply)

**Формула:**
```
result(x,y) = image(x,y) × (value / 100)
```

**Эффект:** Масштабирует значения пикселей

**Особенность:** Значение делится на 100 для более удобного масштабирования

**Пример использования:**
- value = 100: без изменений
- value = 50: уменьшение яркости вдвое
- value = 200: увеличение яркости вдвое

#### 3.4. Деление (Divide)

**Формула:**
```
result(x,y) = image(x,y) / (value / 100)
```

**Эффект:** Обратное масштабирование

**Ограничения:** Деление на ноль запрещено (проверка в коде)

**Важно:** Все операции включают clipping значений в диапазон [0, 255]:
```python
result = np.clip(result, 0, 255).astype(np.uint8)
```

---

### 4. Линейное контрастирование

**Описание:** Метод улучшения контраста путем растяжения гистограммы изображения на заданный диапазон значений.

**Формула:**
```
out(x,y) = (in(x,y) - min_in) × (max_out - min_out) / (max_in - min_in) + min_out
```

где:
- `min_in`, `max_in` — минимальное и максимальное значения входного изображения
- `min_out`, `max_out` — желаемые минимальное и максимальное значения выходного изображения

**Параметры:**
- **Мин. выход** (0-255): минимальное значение результата
- **Макс. выход** (0-255): максимальное значение результата

**Типичные настройки:**

| Цель | min_out | max_out | Эффект |
|------|---------|---------|--------|
| Полный диапазон | 0 | 255 | Максимальный контраст |
| Осветление | 50 | 255 | Убирает темные тона |
| Затемнение | 0 | 200 | Убирает светлые тона |
| Уменьшение контраста | 50 | 200 | Сжатие диапазона |

**Алгоритм:**
1. Найти минимальное и максимальное значения пикселей в изображении
2. Применить линейное преобразование для растяжения/сжатия диапазона
3. Ограничить значения диапазоном [0, 255]

**Применение:**
- Улучшение изображений с низким контрастом
- Нормализация изображений
- Коррекция экспозиции

---

## Технические детали

### Работа с изображениями

#### Форматы изображений

**Внутренний формат:**
- OpenCV использует BGR (Blue-Green-Red) для цветных изображений
- Grayscale для черно-белых изображений
- Тип данных: `np.uint8` (0-255)

**Конвертация для отображения:**
```python
# BGR → RGB для PIL/tkinter
rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)
```

#### Масштабирование для отображения

Изображения автоматически масштабируются для отображения в окне 600×400 пикселей:

```python
def resize_for_display(self, image: np.ndarray) -> np.ndarray:
    h, w = image.shape[:2]
    max_w, max_h = self.display_size
    scale = min(max_w / w, max_h / h)
    
    if scale < 1:
        new_w = int(w * scale)
        new_h = int(h * scale)
        return cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_AREA)
    
    return image
```

**Метод интерполяции:** `cv2.INTER_AREA` — оптимален для уменьшения размера

### Обработка данных

#### Преобразование типов

Многие операции выполняются с `float32` для предотвращения переполнения:

```python
image = self.original_image.astype(np.float32)
# ... операции ...
result = np.clip(result, 0, 255).astype(np.uint8)
```

#### Проверка нечетности размера окна

Для пороговых методов размер окна должен быть нечетным:

```python
if window_size % 2 == 0:
    window_size += 1
```

### Оптимизация вычислений

#### Вычисление стандартного отклонения

Используется формула через математическое ожидание квадрата:

```
σ² = E[X²] - (E[X])²
σ = √(E[X²] - (E[X])²)
```

Реализация:
```python
mean = cv2.blur(image.astype(np.float32), (window_size, window_size))
mean_sq = cv2.blur((image.astype(np.float32) ** 2), (window_size, window_size))
std = np.sqrt(mean_sq - mean ** 2)
```

**Преимущество:** Вычисление за один проход, эффективное использование функции размытия.

---

## Руководство пользователя

### Запуск приложения

1. **Установка зависимостей:**
   ```bash
   pip install -r requirements.txt
   ```

2. **Запуск:**
   ```bash
   python image_processor.py
   ```

### Основной рабочий процесс

#### Шаг 1: Загрузка изображения
1. Нажмите кнопку **"Загрузить изображение"**
2. Выберите файл изображения в диалоговом окне
3. Изображение появится в левой панели ("Исходное изображение")

#### Шаг 2: Выбор метода обработки

**Для пороговой обработки:**
1. Настройте параметры (размер окна, коэффициенты)
2. Нажмите соответствующую кнопку ("Применить Niblack", "Применить Sauvola", "Mean", "Gaussian")
3. Результат появится в правой панели

**Для поэлементных операций:**
1. Установите значение операции
2. Нажмите нужную операцию (Добавить/Вычесть/Умножить/Разделить)

**Для контрастирования:**
1. Установите минимальное и максимальное значения выхода
2. Нажмите "Применить"

#### Шаг 3: Работа с результатом
- **Сбросить:** вернуться к исходному изображению
- **Сохранить результат:** сохранить обработанное изображение в файл

### Рекомендуемые параметры

#### Для текстовых документов:
- **Niblack:** window=15, k=-0.2
- **Sauvola:** window=15, k=0.2
- **Adaptive Gaussian:** window=11, C=2

#### Для фотографий:
- **Adaptive Mean:** window=21, C=5
- **Linear Contrast:** min=0, max=255

#### Для изображений с шумом:
- **Sauvola:** window=25, k=0.3
- Предварительно применить размытие

---

## Примеры использования

### Пример 1: Бинаризация сканированного документа

**Задача:** Преобразовать сканированное изображение документа в черно-белое для OCR.

**Решение:**
1. Загрузить изображение документа
2. Выбрать метод **Sauvola**
3. Параметры: window=15, k=0.2
4. Нажать "Применить Sauvola"
5. Сохранить результат

**Почему Sauvola:** Лучше всего справляется с неравномерным фоном документов.

### Пример 2: Улучшение контраста фотографии

**Задача:** Улучшить тусклую фотографию с низким контрастом.

**Решение:**
1. Загрузить фотографию
2. Выбрать **Линейное контрастирование**
3. Параметры: min=0, max=255
4. Нажать "Применить"
5. При необходимости применить поэлементное умножение (value=120)

### Пример 3: Коррекция темной фотографии

**Задача:** Осветлить недоэкспонированную фотографию.

**Решение:**
1. Загрузить изображение
2. Выбрать **Поэлементные операции → Добавить**
3. Значение: 50
4. Нажать "Добавить"
5. Если нужно больше контраста, применить линейное контрастирование

### Пример 4: Обработка изображения с неравномерным освещением

**Задача:** Выделить объекты на изображении с градиентным освещением.

**Решение:**
1. Загрузить изображение
2. Выбрать **Adaptive Gaussian**
3. Параметры: window=31, C=5
4. Нажать "Gaussian"

---

## Зависимости

### Требуемые библиотеки

```
opencv-python==4.8.1.78   # Обработка изображений
Pillow==10.1.0            # Работа с изображениями для GUI
numpy==1.26.2             # Вычисления с массивами
```

### Встроенные модули Python

- `tkinter` — графический интерфейс (входит в стандартную установку Python)
- `typing` — аннотации типов

### Системные требования

- **Python:** 3.7 или выше
- **ОС:** Windows, macOS, Linux
- **Память:** минимум 2 GB RAM
- **Место на диске:** 100 MB для зависимостей

---

## Обработка ошибок

### Реализованные проверки

1. **Проверка загрузки изображения:**
   ```python
   if self.original_image is not None:
       # обработка
   else:
       messagebox.showerror("Ошибка", "Не удалось загрузить изображение")
   ```

2. **Проверка перед обработкой:**
   ```python
   if self.original_image is None:
       messagebox.showwarning("Предупреждение", "Сначала загрузите изображение")
       return
   ```

3. **Проверка параметров контрастирования:**
   ```python
   if min_out >= max_out:
       messagebox.showerror("Ошибка", "Минимальное значение должно быть меньше максимального")
       return
   ```

4. **Защита от деления на ноль:**
   ```python
   if value == 0:
       messagebox.showerror("Ошибка", "Деление на ноль невозможно")
       return
   ```

---

## Вывод

Приложение предоставляет полный набор инструментов для базовой обработки изображений с акцентом на пороговую обработку и улучшение контраста. Графический интерфейс делает методы доступными для пользователей без программирования, а хорошо структурированный код позволяет легко расширять функциональность.
